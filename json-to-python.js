/*
  Taken from JSON-to-Go (https://github.com/mholt/json-to-go) by Matt Holt
*/

let possible_options = ["dataclass", "pydanticmodel"];

function jsonToPython(json, typename, output_type="pydanticmodel")
{
	if (possible_options.indexOf(output_type) < 0) {
		return -1;
	}
	let data;
	let scope;
	let python_code = "";
	let tabs = 0;
	let end_bracket = false;

	const seen = {};
	const stack = [];
	let accumulator = "";
	let innerTabs = 0;
	let parent = "";
    let parent_original = "";
    let temp_to_append = "";
    
	try
	{
		data = JSON.parse(json.replace(/(:\s*\[?\s*-?\d*)\.0/g, "$1.1")); // hack that forces floats to stay as floats
		scope = data;
	}
	catch (e)
	{
		return {
			python_code: "",
			error: e.message
		};
	}

	typename = format(typename || "AutoGenerated");
	// append(`type ${typename} `);
	append(`from __future__ import annotations\n`)
	append(`from datetime import datetime\n`)

	switch (output_type) {
		case "dataclass":
			append(`from dataclasses import dataclass\n`)
			append(`\n`)
			append(`@dataclass\n`)
			append(`class ${typename}:\n`)
			break;
		case "pydanticmodel":
			append(`from pydantic import BaseModel\n`)
			append(`\n`)
			append(`class ${typename}(BaseModel):\n`)
			break;
	}

	parseScope(scope);
    
    python_code = python_code + accumulator;
    
	return {
		python_code
	};


	function parseScope(scope, depth = 0)
	{
		if (typeof scope === "object" && scope !== null)
		{
			if (Array.isArray(scope))
			{
				let sliceType;
				const scopeLength = scope.length;

				for (let i = 0; i < scopeLength; i++)
				{
					const thisType = pythonType(scope[i]);
					if (!sliceType)
						sliceType = thisType;
					else if (sliceType != thisType)
					{
						sliceType = mostSpecificPossiblePythonType(thisType, sliceType);
						if (sliceType == "Any")
							break;
					}
				}

				let slice = ["struct", "slice"].includes(sliceType)
					? `list[${parent}]`
					: `list[`;
					
				if (slice == "list[") {
				    end_bracket = true;
				} else {
				    end_bracket = false;
				}
				
				if (parent == "") {
					switch (output_type) {
						case "dataclass":
							slice = `\tObjects: list[${typename}List]\n\n@dataclass\nclass ${typename}List:\n`
							break;
						case "pydanticmodel":
							slice = `\tObjects: list[${typename}List]\n\nclass ${typename}List(BaseModel):\n`
							break;
					}
				    
				}

				if (depth >= 2)
					appender(slice);
				else
					append(slice)
				if (sliceType == "struct") {
					const allFields = {};

					// for each field counts how many times appears
					for (let i = 0; i < scopeLength; i++)
					{
						const keys = Object.keys(scope[i])
						for (let k in keys)
						{
							let keyname = keys[k];
							if (!(keyname in allFields)) {
								allFields[keyname] = {
									value: scope[i][keyname],
									count: 0
								}
							}
							else {
								const existingValue = allFields[keyname].value;
								const currentValue = scope[i][keyname];

								if (compareObjects(existingValue, currentValue)) {
									const comparisonResult = compareObjectKeys(
										Object.keys(currentValue),
										Object.keys(existingValue)
									)
									if (!comparisonResult) {
										keyname = `${keyname}_${uuidv4()}`;
										allFields[keyname] = {
											value: currentValue,
											count: 0
										};
									}
								}
							}
							allFields[keyname].count++;
						}
					}

					// create a common struct with all fields found in the current array
					// omitempty dict indicates if a field is optional
					const keys = Object.keys(allFields), struct = {}, omitempty = {};
					for (let k in keys)
					{
						const keyname = keys[k], elem = allFields[keyname];

						struct[keyname] = elem.value;
						omitempty[keyname] = elem.count != scopeLength;
					}
					parseStruct(depth + 1, innerTabs, struct, omitempty); // finally parse the struct !!
				}
				else if (sliceType == "slice") {
					parseScope(scope[0], depth)
				}
				else {
				    temp_to_append = sliceType || "Any";
				    if (end_bracket) {
				        temp_to_append = temp_to_append + "]";
				    }
				    end_bracket = false;
					if (depth >= 2) {
						appender(temp_to_append);
					} else {
						append(temp_to_append);
					}
				}
			}
			else
			{
				temp_to_append = parent;
			    if (end_bracket) {
			        temp_to_append = temp_to_append + "]";
			    }
			    end_bracket = false;
				if (depth >= 2) {
					appender(temp_to_append);
				} else {
					append(temp_to_append);
				}
				parseStruct(depth + 1, innerTabs, scope);
			}
		}
		else {
		    temp_to_append = pythonType(scope);
		    if (end_bracket) {
		        temp_to_append = temp_to_append + "]";
		    }
		    end_bracket = false;
			if (depth >= 2) {
				appender(temp_to_append);
			} else {
				append(temp_to_append);
			}
		}
		end_bracket = false;
	}

	function parseStruct(depth, innerTabs, scope, omitempty)
	{
		stack.push(
			depth >= 2
			? "\n"
			: ""
		)

		const seenTypeNames = [];

		if (depth >= 2)
		{
			const parentType = `${parent}`;
			const scopeKeys = formatScopeKeys(Object.keys(scope));

			// this can only handle two duplicate items
			// future improvement will handle the case where there could
			// three or more duplicate keys with different values
			if (parent in seen && compareObjectKeys(scopeKeys, seen[parent])) {
				stack.pop();
				return
			}
			seen[parent] = scopeKeys;

			// appender(`${parentType} struct {\n`);
// 			appender(`\n`)
			switch (output_type) {
				case "dataclass":
					appender(`@dataclass\n`)
					appender(`class ${parentType}:\n`)
					break;
				case "pydanticmodel":
					appender(`class ${parentType}(BaseModel):\n`)
					break;
			}
			++innerTabs;
			const keys = Object.keys(scope);
			for (let i in keys)
			{
				const keyname = getOriginalName(keys[i]);
				parent_original = keyname;
				indenter(innerTabs)
				const typename = uniqueTypeName(format(keyname), seenTypeNames)
				seenTypeNames.push(typename)

				appender(parent_original+": ");
				parent = typename
				parseScope(scope[keys[i]], depth);
				// appender(' `json:"'+keyname);
				if (omitempty && omitempty[keys[i]] === true)
				{
					// appender(',omitempty');
					appender(' | None');
				}
				// appender('"`\n');
				appender('\n');
			}
			indenter(--innerTabs);
			// appender("}");
		}
		else
		{
			// append("struct {\n");
			++tabs;
			const keys = Object.keys(scope);
			for (let i in keys)
			{
				const keyname = getOriginalName(keys[i]);
				parent_original = keyname;
				indent(tabs);
				const typename = uniqueTypeName(format(keyname), seenTypeNames)
				seenTypeNames.push(typename)
				append(parent_original+": ");
				parent = typename
				parseScope(scope[keys[i]], depth);
				// append(' `json:"'+keyname);
				if (omitempty && omitempty[keys[i]] === true)
				{
					// append(',omitempty');
					append(' | None');
				}
				// append('"`\n');
				append('\n');
			}
			indent(--tabs);
			// append("}");
		}
		accumulator += stack.pop();
	}

	function indent(tabs)
	{
		for (let i = 0; i < tabs; i++)
		python_code += '\t';
	}

	function append(str)
	{
		python_code += str;
	}

	function indenter(tabs)
	{
		for (let i = 0; i < tabs; i++)
			stack[stack.length - 1] += '\t';
	}

	function appender(str)
	{
		stack[stack.length - 1] += str;
	}

	// Generate a unique name to avoid duplicate struct field names.
	// This function appends a number at the end of the field name.
	function uniqueTypeName(name, seen) {
		if (seen.indexOf(name) === -1) {
			return name;
		}

		let i = 0;
		while (true) {
			let newName = name + i.toString();
			if (seen.indexOf(newName) === -1) {
				return newName;
			}

			i++;
		}
	}

	// Sanitizes and formats a string to make an appropriate identifier in Go
	function format(str)
	{
		str = formatNumber(str);

		let sanitized = toProperCase(str).replace(/[^a-z0-9]/ig, "")
		if (!sanitized) {
			return "NAMING_FAILED";
		}

		// After sanitizing the remaining characters can start with a number.
		// Run the sanitized string again trough formatNumber to make sure the identifier is Num[0-9] or Zero_... instead of 1.
		return formatNumber(sanitized)
	}

	// Adds a prefix to a number to make an appropriate identifier in Go
	function formatNumber(str) {
		if (!str)
			return "";
		else if (str.match(/^\d+$/))
			str = "Num" + str;
		else if (str.charAt(0).match(/\d/))
		{
			const numbers = {'0': "Zero_", '1': "One_", '2': "Two_", '3': "Three_",
				'4': "Four_", '5': "Five_", '6': "Six_", '7': "Seven_",
				'8': "Eight_", '9': "Nine_"};
			str = numbers[str.charAt(0)] + str.substr(1);
		}

		return str;
	}

	// Determines the most appropriate Go type
	function pythonType(val)
	{
		if (val === null)
			return "Any";

		switch (typeof val)
		{
			case "string":
				if (/\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)/.test(val))
					return "datetime";
				else
					return "str";
			case "integer":
			    return "int";
			case "number":
				if (val % 1 === 0)
				{
					return "int";
				}
				else
					return "float";
			case "boolean":
				return "bool";
			case "object":
				if (Array.isArray(val))
					return "slice";
				return "struct";
			default:
				return "Any";
		}
	}

	// Given two types, returns the more specific of the two
	function mostSpecificPossiblePythonType(typ1, typ2)
	{
		if (typ1.substr(0, 5) == "float"
				&& typ2.substr(0, 3) == "int")
			return typ1;
		else if (typ1.substr(0, 3) == "int"
				&& typ2.substr(0, 5) == "float")
			return typ2;
		else
			return "Any";
	}

	// Proper cases a string according to Go conventions
	function toProperCase(str)
	{
		// ensure that the SCREAMING_SNAKE_CASE is converted to snake_case
		if (str.match(/^[_A-Z0-9]+$/)) {
			str = str.toLowerCase();
		}

		// https://github.com/golang/lint/blob/5614ed5bae6fb75893070bdc0996a68765fdd275/lint.go#L771-L810
		const commonInitialisms = [
			"ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP",
			"HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA",
			"SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID",
			"URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS"
		];

		return str.replace(/(^|[^a-zA-Z])([a-z]+)/g, function(unused, sep, frag)
		{
			if (commonInitialisms.indexOf(frag.toUpperCase()) >= 0)
				return sep + frag.toUpperCase();
			else
				return sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();
		}).replace(/([A-Z])([a-z]+)/g, function(unused, sep, frag)
		{
			if (commonInitialisms.indexOf(sep + frag.toUpperCase()) >= 0)
				return (sep + frag).toUpperCase();
			else
				return sep + frag;
		});
	}

	function uuidv4() {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
		  var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
		  return v.toString(16);
		});
	}

	function getOriginalName(unique) {
		const reLiteralUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
		const uuidLength = 36;

		if (unique.length >= uuidLength) {
			const tail = unique.substr(-uuidLength);
			if (reLiteralUUID.test(tail)) {
				return unique.slice(0, -1 * (uuidLength + 1))
			}
		}
		return unique;
	}

	function compareObjects(objectA, objectB) {
		const object = "[object Object]";
		return Object.prototype.toString.call(objectA) === object
			&& Object.prototype.toString.call(objectB) === object;
	}

	function compareObjectKeys(itemAKeys, itemBKeys) {
		const lengthA = itemAKeys.length;
		const lengthB = itemBKeys.length;

		// nothing to compare, probably identical
		if (lengthA == 0 && lengthB == 0)
			return true;

		// duh
		if (lengthA != lengthB)
			return false;

		for (let item of itemAKeys) {
			if (!itemBKeys.includes(item))
				return false;
		}
		return true;
	}

	function formatScopeKeys(keys) {
		for (let i in keys) {
			keys[i] = format(keys[i]);
		}
		return keys
	}
}

json = `[
    {
        "input_index": [0],
        "candidate_index": 0,
        "delivery_line_1": "1 N Rosedale St",
        "last_line": ["Baltimore MD 21229-3737"],
        "delivery_point_barcode": "212293737013",
        "components": {
            "primary_number": "1",
            "street_predirection": "N",
            "street_name": "Rosedale",
            "street_suffix": "St",
            "city_name": "Baltimore",
            "state_abbreviation": "MD",
            "zipcode": "21229",
            "plus4_code": "3737",
            "delivery_point": "01",
            "delivery_point_check_digit": "3"
        },
        "metadata": [{
            "record_type": "S",
            "zip_type": "Standard",
            "county_fips": "24510",
            "county_name": "Baltimore City",
            "carrier_route": "C047",
            "congressional_district": "07",
            "rdi": "Residential",
            "elot_sequence": "0059",
            "elot_sort": "A",
            "latitude": 39.28602,
            "longitude": -76.6689,
            "precision": "Zip9",
            "time_zone": "Eastern",
            "utc_offset": -5,
            "dst": true
        }],
        "analysis": {
            "dpv_match_code": "Y",
            "dpv_footnotes": "AABB",
            "dpv_cmra": "N",
            "dpv_vacant": "N",
            "active": "Y"
        }
    },
    {
        "input_index": 0,
        "candidate_index": 1,
        "delivery_line_1": "1 S Rosedale St",
        "last_line": "Baltimore MD 21229-3739",
        "delivery_point_barcode": "212293739011",
        "components": {
            "primary_number": "1",
            "street_predirection": "S",
            "street_name": "Rosedale",
            "street_suffix": "St",
            "city_name": "Baltimore",
            "state_abbreviation": "MD",
            "zipcode": "21229",
            "plus4_code": "3739",
            "delivery_point": "01",
            "delivery_point_check_digit": "1"
        },
        "metadata": {
            "record_type": "S",
            "zip_type": "Standard",
            "county_fips": "24510",
            "county_name": "Baltimore City",
            "carrier_route": "C047",
            "congressional_district": "07",
            "rdi": "Residential",
            "elot_sequence": "0064",
            "elot_sort": "A",
            "latitude": 39.2858,
            "longitude": -76.66889,
            "precision": "Zip9",
            "time_zone": "Eastern",
            "utc_offset": -5,
            "dst": true
        },
        "analysis": {
            "dpv_match_code": "Y",
            "dpv_footnotes": "AABB",
            "dpv_cmra": "N",
            "dpv_vacant": "N",
            "active": "Y"
        }
    }
]`

console.log(jsonToPython(json, "bruh").python_code)
